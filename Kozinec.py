import numpy as np
from math  import log, sqrt
from numpy import linalg
#Обучающие выборки
X_1 = np.array([
    [0.7295200749361322, 0.7286337326606256],
    [0.826505923560258, 0.9403158114766519],
    [0.6023139955320228, 0.4890999051968531],
    [0.7924301535257385, 0.9724603339895345],
    [0.3739062132424882, 0.3807945141554343],
    [0.5213825315815278, 0.7011647516840395],
    [0.5799489554848042, 0.860210492806848],
    [0.4472712889659769, 0.23208680582951224],
    [0.8266928088733442, 0.9708616047497776],
    [0.2096090384196102, 0.07948946448504302],
    [0.33832612728389067, 0.4113630733104253],
    [0.68383264433507, 0.9003136248995234],
    [0.26193673674112883, 0.20727182114712916],
    [0.3974079484193441, 0.44643242592599985]
  ])
X_2 = np.array([
    [0.6721751810634596, 0.18449311250437642],
    [-0.042169919316812694, 0.49680717330122753],
    [0.036908766218045196, 0.23196814194239498],
    [-0.18516646555268645, -0.16324434635897248],
    [0.19909138385183697, -0.20702094026594725],
    [-0.2623894406811841, 0.4468810030788092],
    [0.619550362174564, 0.03980697858179339],
    [0.4418628679007078, -0.0039497588794656585],
    [0.2802286875966722, -0.3525718017732991],
    [0.07448927922989906, -0.4973644925498143],
    [0.6422888179711995, -0.0035410965993326157],
    [0.039664220315716536, 0.34884886593497205],
    [0.4825251758452453, 0.5597992922297098],
    [-0.12480141590985117, 0.3639607311580515],
    [0.45864564291438903, 0.5039088481769888],
    [0.4953345038557703, 0.29819697998837763],
    [0.2106700620743459, -0.2647756656167547],
    [-0.16518914904666915, 0.31212217489262595],
    [0.23046293495668924, -0.013246417684656153]
  ])
X_3 = np.array([
    [0.8281937591326639, -0.48370952458304206],
    [-0.7858693510608477, -0.23619862036716505],
    [-0.71001136864972, 0.41404672725112407],
    [-0.4664238951665492, 0.7619952612050831],
    [-0.457969679633352, 0.6615982411339161],
    [0.5983181292607914, -0.8221655651644655],
    [0.8221320333779605, -0.15771200790888465],
    [-0.49537312338291506, -0.7711426700819444],
    [-0.7422364964100625, 0.7182224765639817],
    [-0.6377879808015602, 0.5664880970210512],
    [-0.9306163344230406, 0.40367110070906637],
    [-0.8220373822748085, 0.6909977471317875],
    [0.8486753113201562, 0.63804443731353],
    [-0.6326025764414666, -0.5660631348100686],
    [-0.7988878989878563, -0.7972747092759437],
    [0.8665672650446975, 0.09077183191199585],
    [0.8297187116097032, -0.19949614828904294],
    [-0.7881099342086356, 0.5319196165347493],
    [-0.6965345338796621, 0.034560747319591745],
    [-0.5844695109910769, 0.8287781873912904]
  ] )
# Вероятность того, что вектор належить розподілу
teta = 0.9
def is_pos_def(x):# положительная определенность матрицы
    return np.all(np.linalg.eigvals(x) > 0)
E = np.array([[1,0],[0,1]])# Дисперсия
E1 = np.array([[-1,0],[0,-1]])
A = np.linalg.inv(E) 
print ("E = \n",A)
m = np.array([0,0])# мат ожидание
print ("m = ",m)
k = 2*log(teta) + m.dot(A.dot(m)) # константа
print ("k = ",k)
print ("E = \n", E)
print ("E1 = \n", E1)
print("E = ", is_pos_def(E))
print ("E1 = ", is_pos_def(E1))
#v_1 = np.array([1,0]) # собственный вектор
#искривля пространство, получаем кси от х и L от A,m,k
def ksi(x):
  """
  >>> ksi([1,0])
  array([1, 0, 0, 0, 1, 1, 0, 0, 1])
  """
  ksi = []
  for j in range (0,2*len(x)):
    for i in range(0,len(x)):
      #print(i+len(x)*j,len(x)*len(x))
      if i+len(x)*j < len(x)*len(x): ksi.append(x[i]*x[j])#, print (x[i]*x[j])
      else: ksi.append(x[j - len(x)]) #, ksi.append(x[j - len(x)])
  ksi.append(1) 
  #print ("ksi(x) = ", ksi)
  return np.array(ksi)

def L (A,m,k):
  """
  >>> L ([[1,0],[0,1]],[0,0],-0.4462871026284194)
  array([ 1.       ,  0.       ,  0.       ,  1.       ,  0.       ,
          0.       ,  0.       ,  0.       , -0.4462871])
  """
  L = []
  for j in range (0,2*len(m)):
    for i in range(0,len(m)):
      if i+len(m)*j < len(m)*len(m): L.append(A[i][j])
      else: L.append(-2*m[i]*A[i][j - len(m)])#, print (m[i],A[i][j - len(m)])
  L.append(k) 
  #print ("L = ", L)
  return np.array(L)
def Kozinec(L,X,k): # k = 1 or  k = - 1
  for i in range (len(X)):
    x = X[i]
    ksi_ = k* np.array(ksi(x))
    if np.dot(L,ksi_) < 0: 
      Gamma= np.array(max((np.dot(-ksi_,L-ksi_))/(np.dot((L-ksi_),(L-ksi_))),0))
      L = np.array(L*Gamma + (1 - Gamma)*ksi_)
      return Kozinec(L,X,k) 
  return L
def Search_Kozinec(X, L):
  """
  >>> Search_Kozinec([[1., 0.],[0., 1]], [ 1.       ,  0.       ,  0.       ,  1.       ,  0.       ,0.       ,  0.       ,  0.       ,1])
  [1, 1]

  """
  Mark = []
  for i in range (len(X)):
    x = X[i]
    ksi_ = ksi(x) 
    #print ("L * ksi_ = ",L.dot(ksi_) )
    if np.dot(L,ksi_) < 0: Mark.append(0)
    else: Mark.append(1)
  return Mark
def L_to_D (L):
  A = []
  n = int(sqrt((len(L)-1)/2))
  for j in range (n):
    A.append([])
    for i in range (n):
      A[j].append(L[j*n+i])
  A = np.array(A)
  #print("A = \n",A)
  return A
def start(L,A,X_1,X_2,X_3,k):
  if k > 490: return L
  elif is_pos_def(A):
    L = Kozinec(L, X_1,1)
    L = Kozinec(L, -X_2, -1)
    #print ("\nL = ", L)

    #print ("Lesson 1")
    Mark_1 = Search_Kozinec(X_1, L)
    Mark_2 = Search_Kozinec(X_2, L)
    Mark_3 = Search_Kozinec(X_3, L)
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    print ("\nMark_1 = ", Mark_1)
    print ("\nMark_2 = ", Mark_2)
    print ("\nMark_3 = ", Mark_3)
    A = L_to_D (L)
    if is_pos_def(A) != 1: start(L,A,X_1,X_2,X_3,k+1)
    for i in range (len(Mark_1)):
      for j in range (len(Mark_2)):
        if Mark_1[i] == 0 or Mark_2[j] == 1 : return  start(L,A,X_1,X_2,X_3,k+1)
  else: 
    print ("Матрица не положительно определена")
    print(A)
    Z = []
    w,v = linalg.eig(A)
    #print(w,v)
    mask = np.logical_and(w<0,w<0)
    #print(mask)
    for i in range (len(v)):
      if mask[i] : Z.append(v[i])
    Z = np.array(Z)
    #print ("Z =\n",Z)
    #print ("X_1 =\n",X_1)
    X_1 = np.concatenate([X_1,Z],axis = 0)
    #print ("X_1 =\n",len(X_1))
    #print ("Z =\n",X_3)
    E = np.array([[1,0],[0,1]])# Дисперсия
    A = np.linalg.inv(E) 
    # m = np.array([0,0])# мат ожидание
    # k = 2*log(teta) + m.dot(A.dot(m)) # константа
    start(L,A,X_1,X_2,X_3,k+1)


L = L (A,m,k)
C = L
start(L,A,X_1,X_2,X_3,0)


# if __name__ == "__main__":
#   import doctest
#   doctest.testmod()

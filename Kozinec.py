import numpy as np
from math  import log 
#Обучающие выборки
X_1 = [
    [0.7295200749361322, 0.7286337326606256],
    [0.826505923560258, 0.9403158114766519],
    [0.6023139955320228, 0.4890999051968531],
    [0.7924301535257385, 0.9724603339895345],
    [0.3739062132424882, 0.3807945141554343],
    [0.5213825315815278, 0.7011647516840395],
    [0.5799489554848042, 0.860210492806848],
    [0.4472712889659769, 0.23208680582951224],
    [0.8266928088733442, 0.9708616047497776],
    [0.2096090384196102, 0.07948946448504302],
    [0.33832612728389067, 0.4113630733104253],
    [0.68383264433507, 0.9003136248995234],
    [0.3974079484193441, 0.44643242592599985],
    [0.26193673674112883, 0.20727182114712916]
  ]
X_2 = [
    [0.6721751810634596, 0.18449311250437642],
    [-0.042169919316812694, 0.49680717330122753],
    [0.036908766218045196, 0.23196814194239498],
    [-0.18516646555268645, -0.16324434635897248],
    [0.19909138385183697, -0.20702094026594725],
    [-0.2623894406811841, 0.4468810030788092],
    [0.619550362174564, 0.03980697858179339],
    [0.4418628679007078, -0.0039497588794656585],
    [0.2802286875966722, -0.3525718017732991],
    [0.07448927922989906, -0.4973644925498143],
    [0.6422888179711995, -0.0035410965993326157],
    [0.039664220315716536, 0.34884886593497205],
    [0.4825251758452453, 0.5597992922297098],
    [-0.12480141590985117, 0.3639607311580515],
    [0.45864564291438903, 0.5039088481769888],
    [0.4953345038557703, 0.29819697998837763],
    [0.2106700620743459, -0.2647756656167547],
    [-0.16518914904666915, 0.31212217489262595],
    [0.23046293495668924, -0.013246417684656153]
  ]
X_3 = [
    [0.7295200749361322, 0.7286337326606256],
    [0.826505923560258, 0.9403158114766519],
    [0.6023139955320228, 0.4890999051968531],
    [0.7924301535257385, 0.9724603339895345],
    [0.3739062132424882, 0.3807945141554343],
    [0.5213825315815278, 0.7011647516840395],
    [0.5799489554848042, 0.860210492806848],
    [0.4472712889659769, 0.23208680582951224],
    [0.8266928088733442, 0.9708616047497776],
    [0.2096090384196102, 0.07948946448504302],
    [0.33832612728389067, 0.4113630733104253],
    [0.68383264433507, 0.9003136248995234],
    [0.3974079484193441, 0.44643242592599985],
    [0.26193673674112883, 0.20727182114712916],
    [0.6721751810634596, 0.18449311250437642],
    [-0.042169919316812694, 0.49680717330122753],
    [0.036908766218045196, 0.23196814194239498],
    [-0.18516646555268645, -0.16324434635897248],
    [0.19909138385183697, -0.20702094026594725],
    [-0.2623894406811841, 0.4468810030788092],
    [0.619550362174564, 0.03980697858179339],
    [0.4418628679007078, -0.0039497588794656585],
    [0.2802286875966722, -0.3525718017732991],
    [0.07448927922989906, -0.4973644925498143],
    [0.6422888179711995, -0.0035410965993326157],
    [0.039664220315716536, 0.34884886593497205],
    [0.4825251758452453, 0.5597992922297098],
    [-0.12480141590985117, 0.3639607311580515],
    [0.45864564291438903, 0.5039088481769888],
    [0.4953345038557703, 0.29819697998837763],
    [0.2106700620743459, -0.2647756656167547],
    [-0.16518914904666915, 0.31212217489262595],
    [0.23046293495668924, -0.013246417684656153]
  ] 
# Вероятность того, что вектор належить розподілу
teta = 0.9
def is_pos_def(x):# положительная определенность матрицы
    return np.all(np.linalg.eigvals(x) > 0)
E = np.array([[1,0],[0,1]])# Дисперсия
E1 = np.array([[-1,0],[0,-1]])
A = np.linalg.inv(E) 
print ("E = \n",A)
m = np.array([0,0])# мат ожидание
print ("m = ",m)
k = 2*log(teta) + m.dot(A.dot(m)) # константа
print ("k = ",k)
print ("E = \n", E)
print ("E1 = \n", E1)
print("E = ", is_pos_def(E))
print ("E1 = ", is_pos_def(E1))
#v_1 = np.array([1,0]) # собственный вектор
#искривля пространство, получаем кси от х и L от A,m,k
def ksi(x):
  """
  >>> ksi([1,0])
  array([1, 0, 0, 0, 1, 1, 0, 0, 1])
  """
  ksi = []
  for j in range (0,2*len(x)):
    for i in range(0,len(x)):
      #print(i+len(x)*j,len(x)*len(x))
      if i+len(x)*j < len(x)*len(x): ksi.append(x[i]*x[j])#, print (x[i]*x[j])
      else: ksi.append(x[j - len(x)]) #, ksi.append(x[j - len(x)])
  ksi.append(1) 
  #print ("ksi(x) = ", ksi)
  return np.array(ksi)

def L (A,m,k):
  """
  >>> L ([[1,0],[0,1]],[0,0],-0.4462871026284194)
  array([ 1.       ,  0.       ,  0.       ,  1.       ,  0.       ,
          0.       ,  0.       ,  0.       , -0.4462871])
  """
  L = []
  for j in range (0,2*len(m)):
    for i in range(0,len(m)):
      if i+len(m)*j < len(m)*len(m): L.append(A[i][j])
      else: L.append(-2*m[i]*A[i][j - len(m)])#, print (m[i],A[i][j - len(m)])
  L.append(k) 
  #print ("L = ", L)
  return np.array(L)
#Поиск нового гаммы 
#-----------------------------------------------------------------------------------------------
def Gamma_new_1 (x,L): # X>
  ksi_ = ksi(x)
  #print (ksi_)
  Gamma_new = max((np.dot(-ksi_,L-ksi_))/(np.dot((L-ksi_),(L-ksi_))),0)
  #print ("Gamma_new_1 ///////////////////// =",Gamma_new)
  return np.array(Gamma_new)
def Gamma_new_2 (x,L): # X<
  ksi_ = ksi(x)
  #print (ksi_)
  Gamma_new = max((np.dot(ksi_,L+ksi_))/(np.dot((L+ksi_),(L+ksi_))),0)
  #print ("Gamma_new_2 ~~~~~~~~~~~~~~~~~~~~~ = ",Gamma_new)
  return np.array(Gamma_new)
#Поиск нового L
def L_new_1 (Gamma,x,L): # X>
  ksi_ = ksi(x)
  L_new = L*Gamma + (1 - Gamma)*ksi_
  #print ("L_new_1 =",L_new)
  return  np.array(L_new)
def L_new_2 (Gamma,x,L): # X<
  ksi_ = ksi(x)
  L_new = L*Gamma - (1 - Gamma)*ksi_
  #print ("L_new_2 =",L_new)
  return  np.array(L_new)

# Алгоритм козинца
def Kozinec(L,X_1,X_2,k):
  #print(k)
  if k > 490: return L
  else:
    k= k+1
    L = Kozinec_1(L,X_1,X_2,k)
    L = Kozinec_2(L,X_1,X_2,k)
    return L
def Kozinec_1(L,X_1,X_2,k): #Алгоритм козинца >
  d = len(X_1)
  """
  >>> Kozinec([ 1.       ,  0.       ,  0.       ,  1.       ,  0.       ,0.       ,  0.       ,  0.       ,1],[[1., 0.],[0., 1]])
  [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1]
  """
  #d = 0 # Специально берем 1 или 2 елемента из выборки, иначе на выходе одни единицы.
  for i in range (d):
    x_1 = X_1[i]
    ksi_ = ksi(x_1) 
    if np.dot(L,ksi_) < 0: 
      Gamma = Gamma_new_1 (x_1,L) 
      #print ("Gamma =",Gamma)
      L = L_new_1 (Gamma,x_1,L)
      #print ("L * ksi_ = ",L.dot(ksi_), i )
      return Kozinec(L,X_1,X_2,k)
  return L
def Kozinec_2(L,X_1,X_2,k): #Алгоритм козинца <
  d = len(X_2)
  #d = 0 # Специально берем 1 или 2 елемента из выборки, иначе на выходе одни единицы.
  for i in range (d):
    x_2 = X_2[i]
    ksi_ = ksi(x_2) 
    if np.dot(L,ksi_) > 0: 
      Gamma = Gamma_new_2 (x_2,L) 
      #print ("Gamma =",Gamma)
      L = L_new_2 (Gamma,x_2,L)
      #print ("L * ksi_ = ",L.dot(ksi_), i )
      return Kozinec(L,X_1,X_2,k)
  return L
# Я осмелился предложить другую фунцию, кторая нагляднее будет показывать, какие вектора принадлежат распределению а какие нет.
def Search_Kozinec(X, L):
  """
  >>> Search_Kozinec([[1., 0.],[0., 1]], [ 1.       ,  0.       ,  0.       ,  1.       ,  0.       ,0.       ,  0.       ,  0.       ,1])
  [1, 1]

  """
  Mark = []
  for i in range (len(X)):
    x = X[i]
    ksi_ = ksi(x) 
    #print ("L * ksi_ = ",L.dot(ksi_) )
    if np.dot(L,ksi_) < 0: Mark.append(0)
    else: Mark.append(1)
  return Mark



if is_pos_def(A):
  L = L (A,m,k)
  L = Kozinec(L, X_1, X_2,0)
  print ("\nL = ", L)

  print ("Lesson 1")
  Mark_1 = Search_Kozinec(X_1, L)
  Mark_2 = Search_Kozinec(X_2, L)
  Mark_3 = Search_Kozinec(X_3, L)
  print ("\nMark_1 = ", Mark_1)
  print ("\nMark_2 = ", Mark_2)
  print ("\nMark_3 = ", Mark_3)
  L = Kozinec(L, X_1, X_2,0)
  print ("\nL = ", L)
  #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  print ("Lesson 2")
  L = Kozinec(L, X_1, X_2,0)
  Mark_1 = Search_Kozinec(X_1, L)
  Mark_2 = Search_Kozinec(X_2, L)
  Mark_3 = Search_Kozinec(X_3, L)
  print ("\nMark_1 = ", Mark_1)
  print ("\nMark_2 = ", Mark_2)
  print ("\nMark_3 = ", Mark_3)
  print ("\nL = ", L)
  #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  print ("Lesson 3")
  L = Kozinec(L, X_1, X_2,0)
  Mark_1 = Search_Kozinec(X_1, L)
  Mark_2 = Search_Kozinec(X_2, L)
  Mark_3 = Search_Kozinec(X_3, L)
  print ("\nMark_1 = ", Mark_1)
  print ("\nMark_2 = ", Mark_2)
  print ("\nMark_3 = ", Mark_3)
  print ("\nL = ", L)
  #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  print ("Lesson 4")
  L = Kozinec(L, X_1, X_2,0)
  Mark_1 = Search_Kozinec(X_1, L)
  Mark_2 = Search_Kozinec(X_2, L)
  Mark_3 = Search_Kozinec(X_3, L)
  print ("\nMark_1 = ", Mark_1)
  print ("\nMark_2 = ", Mark_2)
  print ("\nMark_3 = ", Mark_3)
  print ("\nL = ", L)

  # print ("\nL1= ", L1)
  # print ("\nL2 = ", L2)
  # print ("\nL_final = ", L)
else: print ("Матрица не положительно определена")

if __name__ == "__main__":
  import doctest
  doctest.testmod()
